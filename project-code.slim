// before you start
// git pull

// commit your changes
// git add *
// git commit -m "meaningful message"
// git push

 //SLiM model of evolutionary Rescue
initialize() {
    initializeSLiMModelType("nonWF");
    defineConstant("K", 1000); // carrying capacity for the wild population
    defineConstant("Tdelta", 5000);
    // m1 QTL -> Draws its select coef from norm distrib. w/ mean 0.0 and std dev 1.0
    initializeMutationType("m1", 0.5, "n", 0.0, 1.0); 
    m1.convertToSubstitution = F;
    initializeGenomicElementType("g1", m1, 1.0);
    initializeGenomicElement(g1, 0, 99999);
    initializeMutationRate(1e-7); //  are  these rates for the indigo snake, or are they from the original script? -C
    initializeRecombinationRate(5e-8);
    initializeSex("A");
    defineConstant("buttton", button);
    // defineConstant("m_12", 1e-4); // migration rate from subpop 1 to subpop 2
    // defineConstant("m_21", 1e-4); // migration rate from subpop 2 to subpop 1
    defineConstant("N1", 1000); // size of subpop1; wild Georgia Population 
    defineConstant("N2", 0); //size of subpop2: OCIC breeding colony
    defineConstant("N3", 0); // size of subpop3: Re-introduced population
    defineConstant("Opt1", 5); // Phenotypic optimum
    defineConstant("0pt2", -5); // Phenotypic optimum of the re-introduced population

}
// Reproduction mechanics for the original wild p1 population   
reproduction(p1){
	if (individual.sex == "F") {
		if (individual.age == 3) {
		mate = subpop.sampleIndividuals(1, sex="M", minAge=3);
		litterSize = rpois(1, 6); // not sure how to add litter range of 6-12 to prevent litters smaller than 6
		subpop.addCrossed(individual, mate);
		}
		else if (individual.age >= 4) {
		mate = subpop.sampleIndividuals(1, sex="M", minAge=3);
		litterSize = rpois(1, 8); // same as above for litter range
		subpop.addCrossed(individual, mate);
		}	
	}
}
// Reproduction mechanics for the OCIC p2 population (page 390) -> Breeding individuals must have breeder tag ==1   
reproduction(p2){
	if (individual.sex == "F" & individual.tag == 1) {
		// If individual is in p2 and does NOT have breeder ==1 tag (aka offspring), then individual doesn't mate
		if (individual.age == 3) {
		mate = subpop.sampleIndividuals(1, sex="M", minAge=3, individual.tag ==1); // Male must have breeder tag
		litterSize = rpois(1, 6); // not sure how to add litter range of 6-12 to prevent litters smaller than 6
		subpop.addCrossed(individual, mate);
		individual.tag == 0;
		}
		else if (individual.age >= 4) {
		mate = subpop.sampleIndividuals(1, sex="M", minAge=3, individual.tag ==1); // Male must have breeder tag
		litterSize = rpois(1, 8); // same as above for litter range
		subpop.addCrossed(individual, mate);
		individual.tag == 0;
		}
	//Create if statement to stop p2 offspring from mating, create offpsring tag down for p2 offspring	
	}
}
		
1 { 
    sim.addSubpop("p1", N1);

}   

// TO DO LIST::
//
// Add in something cool about survivability over time (age classes)
// Kill snakes in the first year look into the acclimation effect from Folt et al. (2019)
// Kill GA population
// 

// Variables we will manipulate::
//
// sex ratio of introduced snakes
// Total release number
// Rate of release
// Number of source populations 
// Duration of release

// Variables to track::
// Fitness
// Genetic Diversity
// Population size
// Extinction (How often does it happen and when)
// 
//




//
// think about output to track for the wild subpopulation
// fitness, genotypes,


// Casey start writing code to get the wild population cooking
// Think about output and if you can get a file recording output, great, if not we can figure Wednesday
1:5000 {
early() {
    p1.inds = p1.individuals;
    p1.phenotypes = p1.inds.sumOfMutationsOfType(m1);
    optimum = Opt1;
    deviations = optimum - p1.phenotypes;
    fitnessFunctionMax = dnorm(0.0, 0.0, 5.0);
    adaptation = dnorm(deviations, 0.0, 5.0) / fitnessFunctionMax; // may not need this. What purpose does adding in the adaptation serve.
    p1.inds.fitnessScaling = 0.1 + adaptation * 0.9;
    p1.fitnessScaling = min(K / p1.individualCount, 1.0);
    }
late() {
    if ((sim.generation-1) % 100 == 0);
    catn("Generation: " + sim.generation + " Abundance: " + p1.individualCount + " Phenotypic Mean: " + mean(p1.phenotypes))
}
}

// think about how to do the age structures

// Noah - set up the OCIC breeding colony
// Draws 40 random individuals from subpop p1, the original'wild' population
// Runs 10 generations of offspring creation
// Releases 30 snakes/year into the re-introduced/resident population
// Only 80% of those 30 snakes actually survive due to first year mortality
// -> survival_rate = rbinom(1, 1 , 0.8) where 1 = survival and 0 = death
5000 {
        sim.addSubpop("p2", N2);
}

5001 early() {
	 n1.migrants = 20; // May need to change the migrant p's to n's if doesn't track
    // p2.Individuals = sum(p2.individualCount);
    f.n1.migrants = p1.sampleIndividuals(n1.migrants, sex = "F");
    m.n1.migrants = p1.sampleIndividuals(n1.migrants, sex = "M");
    p2.takeMigrants(c(f.n1.migrants, m.n1.migrants)); //Takes migrants from p1 and puts into p2
    p2.individuals.tag = 1; // Tag original 40 breeder population with 1 and offspring population with 0.
}
    
// should add in some way to separate the breeders from the offspring so we only pull from offspring 
// should explore maintaining some sort of sex ratio for the migration rate, we can pull this from the n3 migration

5010 {
    sim.addSubpop("p3", N3);
}


// // Set up the re-introduced population
// fitness(m2) { return 1.0; }

5011:5500 early() {
// need to set up the migration block to pull 30 individuals from the OCIC population
// Make sure the 30 individuals pulled are individual.tag == 0 (so they are offspring and not breeders)
// In theory this block will remove 15 males and 15 females from the OCIC population and migrate them into p3
	p2.migrants = 15;
    // p2.Individuals = sum(p2.individualCount);
    f.p2.migrants = p2.sampleIndividuals(p2.migrants, sex = "F");
    m.p2.migrants = p2.sampleIndividuals(p2.migrants, sex = "M");
    p3.takeMigrants(c(f.p2.migrants, m.p2.migrants));

    kill = p3.sampleIndividuals(p2.IndividualCount * 0.2);
    kill.fitnessScaling = 0.0;
}



// Need to work out the fitness function so that the re-introduced moves towards its optimum
fitness(m1) {return 1.0;}

5011: early() {
    if (p3.individuals == 0)
    {catn("Population went extinct at generation: " + sim.generation)}
    p3.inds = p3.individuals;
    phenotypes = p3.inds.sumOfMutationsOfType(m1);
    optimum = Opt2;
    deviations = optimum - phenotypes;
    fitnessFunctionMax = dnorm(0.0, 0.0, 5.0);
    adaptation = dnorm(deviations, 0.0, 5.0) / fitnessFunctionMax; // may not need this. What purpose does adding in the adaptation serve.
    inds.fitnessScaling = 0.1 + adaptation * 0.9;
    inds.tagF = phenotypes; // just for output below
    // density-dependence with a maximum benefit at low density
    p3.fitnessScaling = min(K / p1.individualCount, 1.0);

}

if (sim.generation % 100 == 0)
catn(sim.generation + ": Mean phenotype == " + mean(phenotypes) + "Population Size: " + p3.inds);


// 30 snakes per year, .50 sex ratio eventually 
}
